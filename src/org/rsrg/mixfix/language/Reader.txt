package org.rsrg.mixfix.language;

import io.vavr.collection.HashMap;
import io.vavr.collection.List;
import io.vavr.collection.Map;
import org.rsrg.resolve.api.Resolve;
import org.rsrg.resolve.language.CompilationMessage;
import org.rsrg.resolve.language.ast.Ast.*;
import org.rsrg.resolve.util.immutableadts.Validation;

import java.io.IOException;
import java.nio.file.Files;

import static org.rsrg.resolve.util.immutableadts.Validation.success;

/**
 * An initial phase of compilation that converts a raw source input data
 * into buffer memory.
 * <operatorPrecedences>
 * The input to the reader is an {@link Input} object (either a document,
 * package, or a raw string) and the output is an {@link Source} object that
 * stores:
 * <ol>
 *     <li>the text for the source into a character buffer in preparation for
 *     lexing and parsing, and</li>
 *     <li>a boolean indicating whether a source is stable (whether it cannot
 *     change after being loaded)</li>
 * </ol>
 * Sp this phase should not be conflated with "lexer" as all it does is load
 * text into a buffer (even if it's lexically/syntactically invalid text).
 */
public final class Reader {

    public static Validation<Map<Source, Void>, CompilationMessage> run(
            List<Input> inputs, Resolve resolve) {

        return resolve.phase("Reader", () -> {
            Map<Source, Void> result = HashMap.empty();

            for (Input input : inputs) {
                switch (input) {
                    case Text t -> {
                        var src = new Source(
                                input, t.text().toCharArray(), t.stable());
                        result = result.put(src, null);
                    }
                    case TxtFile t -> {
                        try {
                            var bytes = Files.readAllBytes(t.path());
                            var str = new String(bytes, resolve.defaultCharset);
                            var arr = str.toCharArray();
                            var src = new Source(input, arr, false);
                            result = result.put(src, null);
                        } catch (IOException e) {
                            throw new RuntimeException(e.getMessage());
                        }
                    }
                    case PkgFile t -> {
                        throw new UnsupportedOperationException(
                                "not implemented");
                    }
                }
            }
            // validation.success encapsulates an (empty) list of
            // CompilationMessage error instances and a collection of Source
            // program text that the user asked to compile on the cmdline

            // validation.failure only gives back a (nonempty!) list of
            // CompilationMessage error instances
            return success(result);
        });
    }
}
